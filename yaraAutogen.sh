#!/usr/bin/env bash

#function to display banner
echo -e "\033[1;31m"
usuage(){
	cat<<EOF
              <USUAGE>: ${0} -a -A -b -h -r -p 

              				-a : It display About malware
              				-A : It select & creates ADVANCE yara rule 
              				-b : It select & creates BASIC yara rule 
              				-r : It select RECURSIVE SCAN option 
              				-h : It display help menu 
              				-p : It select Windows PE files
EOF
}
if [[ $# -eq 0 ]];
then 
	usuage
	exit
fi


About_func(){ 
echo -e "\033[1;33m ABOUT MALWARE :"
echo -e "\033[0;35m malware is short for malicious software and refers to any software that is designed to cause harm to computer systems, networks, or users. Malware can take many forms. Itâ€™s important for individuals and organizations to be aware of the different types of malware and take steps to protect their systems, such as using antivirus software, keeping software and systems up-to-date, and being cautious when opening email attachments or downloading software from the internet."

echo -e "\033[1;33m Types of Malware "
echo -e "\033[1;35m 1:VIRUSES "
echo -e "\033[0;38mA Virus is a malicious executable code attached to another executable file. The virus spreads when an infected file is passed from system to system. Viruses can be harmless or they can modify or delete data. Opening a file can trigger a virus. Once a program virus is active, it will infect other programs on the computer."
echo -e "\033[1;35m 2:WORMS  "
echo -e "\033[0;38m Worms replicate themselves on the system, attaching themselves to different files and looking for pathways between computers, such as computer network that shares common file storage areas. Worms usually slow down networks. A virus needs a host program to run but worms can run by themselves. After a worm affects a host, it is able to spread very quickly over the network."
echo -e "\033[1;35m 3:Trojen Horse  "
echo -e "\033[0;38m A Trojan horse is malware that carries out malicious operations under the appearance of a desired operation such as playing an online game. A Trojan horse varies from a virus because the Trojan binds itself to non-executable files, such as image files, and audio files."

}
baisc_SCANfun(){
 	
 	display_Banner(){

	figlet -f Small "YARAAutoGEN"|boxes -d jstone -a hc|lolcat

}
display_Banner



FILE_PATH=" "
echo -e -n "\033[0;35mENTER FILE NAME TO SCAN (ABSOLUTE PATH):" 
read   FILE_PATH

#function for checking if the file present or not 

	
#function for checking if the file present or not 
file_check(){
	
	echo -e "\033[1;33m[+]\033[1;32mchecking if file exits or not "
if [ -e "$FILE_PATH" ]; 

then 
       echo -e "\033[1;35m<==>\033[1;36mINPUT FILE TAKEN AND EXITS\033[1;35m<==>"
       size=$(stat -c %s $FILE_PATH)
	   in_kb=$(( size / 1024 ))
	   if [[ $in_kb -lt 6 ]];
	   then 
		echo -e "\033[1;36m[#]\033[1;34msorry your file size  too small <6kb So Enter >6kb \033[1;36m[#]"
		echo -e "\033[1;31m[*]I am Quitting Now.....  Rexecute Script.............."
		exit
	    fi
else
		echo -e "\033[1;31m[-]FILE NOT FOUND "
       echo -e -n "\033[0;32mIF YOU WANT TO RENTER YOUR FILE PATH(y/n):" 
       read  check
	 	  
	 	if [[ $check =~ N|n ]];
	 	then  
			echo -e "\033[1;36m THANKS !!!!!!!!!!!!!!!!!!!!!!"
		    exit
		  elif [[ $check =~ Y|y ]]; then
				echo  -e -n "\033[0;35mENTER FILE NAME TO SCAN (PATH):" 
				read  FILE_PATH
		  	file_check
		fi
		  	
fi
}
ori_dirName="$(dirname "$FILE_PATH")" 
extract_file="$(basename "$FILE_PATH" |cut -d "." -f1)"
new_dir="$ori_dirName/yaraRULE_$extract_file"
#function for creating new directory 
create_Dirfun(){
       echo -e "\033[1;30m[+]\033[1;34mChecking if directory is present to store yar files"
            #dirfile="$ori_driName/yara_$extract_file"
            if [[ -d $new_dir ]]; then
            		
            	echo -e "\033[1;31m[-]$new_dir already exits Sooooooo removing"
            	rm -rf "$new_dir"
             fi
             echo -e "\033[1;30m[+]\033[1;34mCreating directory and CD to that directory"
             mkdir -p "$new_dir"
             cd "$new_dir"
}
      			 
      			 #file and strings extraction 
      			 outputRuleFile="$new_dir/generated_rule.yara"
      			 out_check=$(file -i $FILE_PATH|grep -E "inode|directory|text|plain")
               if [[ $out_check =~ "inode|directory|text|plain" ]];
               then 
					my_strings=$(strings $FILE_PATH 2>/dev/null|cut -d " ", -f 1-10 |head -n 15|xargs -n1) 
					 #word_coutns=$(strings $FILE_PATH |cut -d " ", -f 1-10 |head -n 15|xargs -n1 |wc -w )
				else
                  my_strings=$(strings $FILE_PATH 2>/dev/null |grep -io -E "^([a-z0-9]{4,}$)"|head -30)
                  #word_coutns=$(strings $FILE_PATH |cut -d " " -f 1-10 |head -n 15|xargs -n1 |wc -w )

                fi
  

file_check
create_Dirfun

my_ranarrr=(2 3 4 5 6 8 9 1 12)



	         echo "rule YaraBasicRULE {" >"$outputRuleFile"
             echo "       strings:" >> "$outputRuleFile"
             
             counter=1
			 your_array=("xor" "fullword" "fullword ascii" "base64 wide" "nocase" "wide ascii")
			 
			 while IFS= read -r string; do
				word_to_add=${your_array[$((RANDOM % ${#your_array[@]}))]}
    		echo "    \$s_$counter = \"$string\"" "$word_to_add" >>"$outputRuleFile"
   				((counter++))
			done <<<"$my_strings"
	
			echo "" >> "$outputRuleFile"
			echo "  condition:" >> "$outputRuleFile"
		     no_1=${my_ranarrr[$((RANDOM % ${#my_ranarrr[@]}))]}
		     no_2=${my_ranarrr[$((RANDOM % ${#my_ranarrr[@]}))]}
             no_3=${my_ranarrr[$((RANDOM % ${#my_ranarrr[@]}))]}
		     no_4=${my_ranarrr[$((RANDOM % ${#my_ranarrr[@]}))]}
		     no_5=${my_ranarrr[$((RANDOM % ${#my_ranarrr[@]}))]}
		     no_6=${my_ranarrr[$((RANDOM % ${#my_ranarrr[@]}))]}
		     no_7=${my_ranarrr[$((RANDOM % ${#my_ranarrr[@]}))]}


			echo -e "   3 of (\$s_$no_1,\$s_$no_7,\$s_$no_6,\$s_$no_5,\$s_$no_2)  " >> "$outputRuleFile"
			echo -e "   and  \$s_$no_4 at 100 ">>"$outputRuleFile"
			echo -e  " 	or any of them">>"$outputRuleFile"
			echo "}" >> "$outputRuleFile"

} 2>/dev/null	
# my_hexstr=$(hd  $FILE_PATH 2>/dev/null|head -6|cut -d " " -f 3-10|sed -e '1 s/[0-9][0-9]/??/3' -e 's/[0-9][0-9]/??/6'  -e '3 s/[0-9][0-9]/[12-]/3' -e '4 s/[0-9][0-9]/(01 5d|43 7e)/5' -e '5 s/[0-9]/?/5' -e '6 s/[a-z][0-9]/??/' -e '6 s/[0-9][0-9]/(?? fe|0? ?a)/1' |cut -d " " -f 1-9|sed -e 's/^/{/' -e 's/$/}/' )


advance_Scan(){

	display_Banner(){

	figlet -f Small "YARAAutoGEN"|boxes -d jstone -a hc|lolcat

}
display_Banner

	FILE_PATH1=" "
	echo -e -n "\033[0;35mENTER FILE NAME TO SCAN (ABSOLUTE PATH):" 
   read   FILE_PATH1
	filecheck1(){


#function for checking if the file present or not 

	echo -e "\033[1;33m[+]\033[1;32mchecking if file exits or not "
if [ -e "$FILE_PATH1" ]; 

then 
       echo -e "\033[1;35m<==>\033[1;36mINPUT FILE TAKEN AND EXITS\033[1;35m<==>"
       size1=$(stat -c %s $FILE_PATH1)
	   in_kb1=$(( size1 / 1024 ))
	   if [[ $in_kb1 -lt 6 ]];
	   then 
		echo -e "\033[1;36m[#]\033[1;34msorry your file size  too small <6kb So Enter >6kb \033[1;36m[#]"
		echo -e "\033[1;31m[*]I am Quitting Now.....  Rexecute Script.............."
		exit
	    fi
else
		echo -e "\033[1;31m[-]FILE NOT FOUND "
       echo -e -n "\033[0;32mIF YOU WANT TO RENTER YOUR FILE PATH(y/n):" 
       read  check1
	 	  
	 	if [[ $check1 =~ N|n ]];
	 	then  
			echo -e "\033[1;36m THANKS !!!!!!!!!!!!!!!!!!!!!!"
		    exit
		  elif [[ $check1 =~ Y|y ]]; then
				echo  -e -n "\033[0;35mENTER FILE NAME TO SCAN (PATH):" 
				read  FILE_PATH1
		  	file_check1
		fi
		  	
fi
}
ori_dirName1="$(dirname "$FILE_PATH1")" 
extract_file1="$(basename "$FILE_PATH1" |cut -d "." -f1)"
new_dir1="$ori_dirName1/yaraRULE_$extract_file1"
#function for creating new directory 
    cre_dir1(){
       echo -e "\033[1;30m[+]\033[1;34mChecking if directory is present to store yar files"
            #dirfile="$ori_driName/yara_$extract_file"
            if [[ -d $new_dir1 ]]; then
            		
            	echo -e "\033[1;31m[-]$new_dir already exits Sooooooo removing"
            	rm -rf "$new_dir1"
             fi
             echo -e "\033[1;30m[+]\033[1;34mCreating directory and CD to that directory"
             mkdir -p "$new_dir1"
             cd "$new_dir1"

      			 
      			 #file and strings extraction 
      			 outputRuleFile1="$new_dir1/generated_Advancerule.yara"
      			 out_check1=$(file -i $FILE_PATH1|grep -E "inode|directory|text|plain")
               if [[ $out_check1 =~ "inode|directory|text|plain" ]];
               then 
					my_strings1=$(strings $FILE_PATH1 2>/dev/null|cut -d " ", -f 1-10 |head -n 15|xargs -n1) 
					 #word_coutns=$(strings $FILE_PATH |cut -d " ", -f 1-10 |head -n 15|xargs -n1 |wc -w )
				else
                  my_strings1=$(strings $FILE_PATH1 2>/dev/null |grep -io -E "^([a-z0-9]{4,}$)"|head -30)
                  #word_coutns=$(strings $FILE_PATH |cut -d " " -f 1-10 |head -n 15|xargs -n1 |wc -w )

                fi
    }

    filecheck1
    cre_dir1

my_ranarrr1=(2 3 4 5 6 8 9 1 12)
my_hexstr1=$(hd  $FILE_PATH1 2>/dev/null|head -6|cut -d " " -f 3-10|sed -e '1 s/[0-9][0-9]/??/3' -e 's/[0-9][0-9]/??/6'  -e '3 s/[0-9][0-9]/[12-]/3' -e '4 s/[0-9][0-9]/(01 5d|43 7e)/5' -e '5 s/[0-9]/?/5' -e '6 s/[a-z][0-9]/??/' -e '6 s/[0-9][0-9]/(?? fe|0? ?a)/1' |cut -d " " -f 1-9|sed -e 's/^/{/' -e 's/$/}/' )


	echo "rule YaraAdvanceRULE {" >"$outputRuleFile1"
             echo "       strings:" >> "$outputRuleFile1"
             
             counter1=1
             number1=1
			 your_array1=("xor" "fullword" "fullword ascii" "base64 wide" "nocase" "wide ascii")
			 
			 while IFS= read -r string; do
				word_to_add=${your_array1[$((RANDOM % ${#your_array1[@]}))]}
    		echo "    \$s_$counter1 = \"$string\"" "$word_to_add" >>"$outputRuleFile1"
   				((counter1++))
			done <<<"$my_strings1"
	         while IFS= read -r hexval;do
	         	echo "   \$hex_$number1" = " $hexval " >>"$outputRuleFile1"
	             ((number1++))
	         done <<<"$my_hexstr1"
			echo "" >> "$outputRuleFile1"
			echo "  condition:" >> "$outputRuleFile1"
		    echo "   (uint32(0)==0x464c457f) or (uint32(0) == 0xfeedfacf) or (uint32(0) == 0xcffaedfe) or (uint32(0) == 0xfeedface) ">> "$outputRuleFile1"
			echo " and uint16(0) == 0x5A4D ">>"$outputRuleFile1"
			echo "    or (filesize>512) and not (filesize>5MB) ">>"$outputRuleFile1"
			echo "    and  4 of (\$hex_1,\$hex_2,\$hex_3,\$hex_4,\$hex_5,\$hex_6)">>"$outputRuleFile1"
			echo "     or any of them ">>"$outputRuleFile1"
			 no_1=${my_ranarrr1[$((RANDOM % ${#my_ranarrr1[@]}))]}
		     no_2=${my_ranarrr1[$((RANDOM % ${#my_ranarrr1[@]}))]}
             no_3=${my_ranarrr1[$((RANDOM % ${#my_ranarrr1[@]}))]}
		     no_4=${my_ranarrr1[$((RANDOM % ${#my_ranarrr1[@]}))]}
		     no_5=${my_ranarrr1[$((RANDOM % ${#my_ranarrr1[@]}))]}
		     no_6=${my_ranarrr1[$((RANDOM % ${#my_ranarrr1[@]}))]}
		     no_7=${my_ranarrr1[$((RANDOM % ${#my_ranarrr1[@]}))]}
			echo -e "  or  4 of (\$s_$no_1,\$s_$no_7,\$s_$no_6,\$s_$no_5,\$s_$no_2)  " >> "$outputRuleFile1"
			echo -e "   and  \$s_$no_4 at 100 ">>"$outputRuleFile1"
			echo "}" >> "$outputRuleFile1"

			



					
} 2>/dev/null	

PE_func(){

		display_Banner(){

	figlet -f Small "YARAAutoGEN"|boxes -d jstone -a hc|lolcat

}
display_Banner

	FILE_PATH2=" "
	echo -e -n "\033[0;35mENTER FILE NAME TO SCAN (ABSOLUTE PATH):" 
   read   FILE_PATH2
	filecheck2(){


#function for checking if the file present or not 

	echo -e "\033[1;33m[+]\033[1;32mchecking if file exits or not "
if [ -e "$FILE_PATH2" ]; 

then 
       echo -e "\033[1;35m<==>\033[1;36mINPUT FILE TAKEN AND EXITS\033[1;35m<==>"
       size2=$(stat -c %s $FILE_PATH2)
	   in_kb2=$(( size2 / 1024 ))
	   if [[ $in_kb2 -lt 6 ]];
	   then 
		echo -e "\033[1;36m[#]\033[1;34msorry your file size  too small <6kb So Enter >6kb \033[1;36m[#]"
		echo -e "\033[1;31m[*]I am Quitting Now.....  Rexecute Script.............."
		exit
	    fi
else
		echo -e "\033[1;31m[-]FILE NOT FOUND "
       echo -e -n "\033[0;32mIF YOU WANT TO RENTER YOUR FILE PATH(y/n):" 
       read  check2
	 	  
	 	if [[ $check2 =~ N|n ]];
	 	then  
			echo -e "\033[1;36m THANKS !!!!!!!!!!!!!!!!!!!!!!"
		    exit
		  elif [[ $check2 =~ Y|y ]]; then
				echo  -e -n "\033[0;35mENTER FILE NAME TO SCAN (PATH):" 
				read  FILE_PATH2
		  	file_check1
		fi
		  	
fi
}
ori_dirName2="$(dirname "$FILE_PATH2")" 
extract_file2="$(basename "$FILE_PATH2" |cut -d "." -f1)"
new_dir2="$ori_dirName2/yaraRULE_$extract_file2"
#function for creating new directory 
    cre_dir2(){
       echo -e "\033[1;30m[+]\033[1;34mChecking if directory is present to store yar files"
            #dirfile="$ori_driName/yara_$extract_file"
            if [[ -d $new_dir2 ]]; then
            		
            	echo -e "\033[1;31m[-]$new_dir already exits Sooooooo removing"
            	rm -rf "$new_dir2"
             fi
             echo -e "\033[1;30m[+]\033[1;34mCreating directory and CD to that directory"
             mkdir -p "$new_dir2"
             cd "$new_dir2"

      			 
      			 #file and strings extraction 
      			 outputRuleFile2="$new_dir2/generated_PErule.yara"
      			 out_check2=$(file -i $FILE_PATH2|grep -E "inode|directory|text|plain")
               if [[ $out_check2 =~ "inode|directory|text|plain" ]];
               then 
					my_strings2=$(strings $FILE_PATH2 2>/dev/null|cut -d " ", -f 1-10 |head -n 15|xargs -n1) 
					 #word_coutns=$(strings $FILE_PATH |cut -d " ", -f 1-10 |head -n 15|xargs -n1 |wc -w )
				else
                  my_strings2=$(strings $FILE_PATH2 2>/dev/null |grep -io -E "^([a-z0-9]{4,}$)"|head -30)
                  #word_coutns=$(strings $FILE_PATH |cut -d " " -f 1-10 |head -n 15|xargs -n1 |wc -w )

                fi
    }

    filecheck2
    cre_dir2






	    echo "inport pe" >"$outputRuleFile2"
	  echo "rule YaraBasicRULE {" >>"$outputRuleFile2"
      echo " meta:"       >> "$outputRuleFile2"

echo "author" = "Neil Fox <@@xf@x_>">> "$outputRuleFile2"
echo "filetype" = "Win32 EXE" >>"$outputRuleFile2"
echo "date" = "03/30/2021" >>"$outputRuleFile2"
echo "version" = "1.9">>"$outputRuleFile2"
echo "reference" = "https://app.any.run/tasks/05c0a277-509a-435b-b691 -e79142d7b069/">>"$outputRuleFile2"
echo md5 = "158E5DD95884449919421D4BA79E8E88">>"$outputRuleFile2"

echo "strings:">>"$outputRuleFile2"
echo "$al= \"PSAPI.d11\" fullword ascii" >>"$outputRuleFile2"

echo "$b1 = \"CreateToolhelp32Snapshot\" fullword ascii">>"$outputRuleFile2"
echo "$b2 = \"GetCursorPos\" fullLword ascii">>"$outputRuleFile2"
echo "$b3 = \"GetKeyboardType\" fulLword ascii">>"$outputRuleFile2"
echo "$b4 = \"GetKeyState\" fullword ascii">>"$outputRuleFile2"
echo "$b5 = \"EnumWindows\" fullword ascii">>"$outputRuleFile2"
echo "$b6 = \"EnumDeviceDrivers\" fullword ascii">>"$outputRuleFile2"
echo "$b7 = \"UrlMon\" fullword ascii">>"$outputRuleFile2"
echo "$c1 = \"disk@$&%19.pakv\" fullword ascii">>"$outputRuleFile2"
echo "$c2 = \"@$&%O1\VR\Versium Research\" fulLword ascii">>"$outputRuleFile2"
echo "$c3 = \"@$&%O4\8tOSLOFJZXUHN.exe\" fullword ascii">>"$outputRuleFile2"
echo "$c3 = \"Launch Versium Research\" fullword ascii">>"$outputRuleFile2"
echo condition:>>"$outputRuleFile2"
echo "uint16(0) == @x5A4D">>"$outputRuleFile2"
echo "and pe.version_info["FileDescription"] contains "Versium Research 5 Installation"">>"$outputRuleFile2"
echo "and pe.imports["FDIDestroy", "FDICopy", "FDICreate" ]">>"$outputRuleFile2"
echo "and pe.sections[@].name == "cope"">>"$outputRuleFile2"
echo "and pe.sections[2].name == "BSS"">>"$outputRuleFile2"
echo "and (($a*) or 3 of ($b*) or 1 of ($c*)">>"$outputRuleFile2"
echo "and filesize < 50eee">>"$outputRuleFile2"
echo "}" >> "$outputRuleFile2"

} 2>/dev/null	


    


while getopts ":aAbhrp" OPTIONS ;
do 

	case $OPTIONS in 

		a) 
			echo -e "\033[1;33m[+]\033[1;35m YOUR CHOOSESN DISPLAY ABOUT MALWARE AND ITS TYPE"
			About_func
			exit
			;;
		A) 
			  echo -e "\033[1;33m[+]\033[1;35m YOU SELECTED ADVANCE SCAN TYPE"
                      advance_Scan

                      echo -n -e "\033[1;31m[-]if you want scan now type \033[1;36m(S|scan)\033[1;31m are you want to create a rule file type \033[1;36m(C|create) :"
                      read scan_create
                      if [[ $scan_create =~ s|S|scan ]];then
                      	yara -s $outputRuleFile1 $FILE_PATH1 
                      	echo -e "\033[1;33m[=>]\033[0;32m and your ADVANCE rule file created here : $outputRuleFile1"
                      else 
						echo -e "\033[1;33m[=>]\033[0;32m your ADVACE rule file created here : $outputRuleFile1"
                      fi

   
                     ;;

        b)   
				 echo -e "\033[1;33m[+]\033[1;35m YOU SELECTED BASIC SCAN TYPE"
                      baisc_SCANfun
                      echo -n -e "\033[1;31m[-]if you want scan now type \033[1;36m(S|scan)\033[1;31m are you want to create a rule file type \033[1;36m(C|create) : "
                      read scan_create
                      if [[ $scan_create =~ s|S|scan ]];then
                      	yara -s $outputRuleFile $FILE_PATH 
                      	echo -e "\033[1;33m[=>]\033[0;32m and your BASIC rule file created here : $outputRuleFile"
                      else 
						echo -e "\033[1;33m[=>]\033[0;32m your BASIC rule file created here : $outputRuleFile"
                      fi
                     ;;
        h) 
					echo -e "\033[1;33m[+]\033[1;35m DISPLAYING  HELP MENU "
					usuage
					exit
					;;
		p)  		
						
					echo -e "\033[1;33m[+]\033[1;35m YOU SELECTED PE file SCAN TYPE"
                      PE_func
                      echo -n -e "\033[1;31m[-]if you want scan now type \033[1;36m(S|scan)\033[1;31m are you want to create a rule file type \033[1;36m(C|create) : "
                      read scan_create
                      if [[ $scan_create =~ s|S|scan ]];then
                      	yara -s $outputRuleFile2 $FILE_PATH2 
                      	echo -e "\033[1;33m[=>]\033[0;32m and your PE rule file created here : $outputRuleFile2"
                      else 
						echo -e "\033[1;33m[=>]\033[0;32m your PE rule file created here : $outputRuleFile2"
                      fi
                     ;;
        r)  
		
					echo -e "\033[1;33m[+]\033[1;35m YOU SELECTED RECURSIVE ADVANCE SCAN TYPE"
                      advance_Scan
                      echo -n -e "\033[1;31m[-]if you want scan now type \033[1;36m(S|scan)\033[1;31m are you want to create a rule file type \033[1;36m(C|create) :"
                      read scan_create
                      if [[ $scan_create =~ s|S|scan ]];then
                      	yara -s $outputRuleFile1 $ori_dirName1/. 
                      	echo -e "\033[1;33m[=>]\033[0;32m and your ADVANCE rule file created here : $outputRuleFile1"
                      else 
						echo -e "\033[1;33m[=>]\033[0;32m your ADVACE rule file created here : $outputRuleFile1"
                      fi
                     ;;
        \?)
						echo -e "\033[1;32m INVALID OPTIONS "
						usuage
						exit
						;;
	esac
done 
